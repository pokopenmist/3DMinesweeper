<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Minesweeper</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;500;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Rajdhani', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            overflow: hidden;
            color: #e0e0e0;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        canvas {
            display: block;
        }
        
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .header {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: auto;
        }
        
        .title {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5rem;
            font-weight: 900;
            background: linear-gradient(135deg, #00f5ff 0%, #ff00e5 50%, #00ff9d 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(0, 245, 255, 0.5);
            letter-spacing: 0.3em;
            margin-bottom: 5px;
        }
        
        .subtitle {
            font-size: 0.9rem;
            color: #888;
            letter-spacing: 0.5em;
            text-transform: uppercase;
        }
        
        .stats-panel {
            position: absolute;
            top: 100px;
            left: 20px;
            background: rgba(10, 10, 20, 0.85);
            border: 1px solid rgba(0, 245, 255, 0.3);
            border-radius: 12px;
            padding: 15px;
            min-width: 140px;
            backdrop-filter: blur(10px);
            pointer-events: auto;
        }
        
        .stat-item {
            margin-bottom: 12px;
        }
        
        .stat-label {
            font-size: 0.7rem;
            color: #00f5ff;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            margin-bottom: 3px;
        }
        
        .stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: #fff;
        }
        
        .stat-value.mines {
            color: #ff00e5;
        }
        
        .stat-value.flags {
            color: #00ff9d;
        }
        
        .controls-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            pointer-events: auto;
        }
        
        .btn {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.85rem;
            font-weight: 700;
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #00f5ff 0%, #0099ff 100%);
            color: #000;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 245, 255, 0.4);
        }
        
        .btn-secondary {
            background: transparent;
            color: #00f5ff;
            border: 1px solid rgba(0, 245, 255, 0.5);
        }
        
        .btn-secondary:hover {
            background: rgba(0, 245, 255, 0.1);
            border-color: #00f5ff;
        }
        
        .help-panel {
            position: absolute;
            top: 100px;
            right: 20px;
            background: rgba(10, 10, 20, 0.85);
            border: 1px solid rgba(255, 0, 229, 0.3);
            border-radius: 12px;
            padding: 20px;
            max-width: 220px;
            backdrop-filter: blur(10px);
            pointer-events: auto;
        }
        
        .help-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            color: #ff00e5;
            margin-bottom: 15px;
            letter-spacing: 0.1em;
        }
        
        .help-item {
            font-size: 0.85rem;
            color: #aaa;
            margin-bottom: 10px;
            line-height: 1.4;
        }
        
        .help-item span {
            color: #fff;
            font-weight: 500;
        }
        
        .game-message {
            position: absolute;
            bottom: 150px;
            left: 20px;
            text-align: center;
            pointer-events: auto;
            display: none;
            cursor: move;
            user-select: none;
        }
        
        .game-message.show {
            display: block;
            animation: fadeIn 0.5s ease;
        }
        
        .game-message.dragging {
            opacity: 0.9;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }
        
        .message-box {
            background: rgba(10, 10, 20, 0.75);
            border: 2px solid;
            border-radius: 15px;
            padding: 25px 40px;
            backdrop-filter: blur(5px);
        }
        
        .message-box.win {
            border-color: #00ff9d;
            box-shadow: 0 0 60px rgba(0, 255, 157, 0.3);
        }
        
        .message-box.lose {
            border-color: #ff0055;
            box-shadow: 0 0 60px rgba(255, 0, 85, 0.3);
        }
        
        .message-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 2rem;
            font-weight: 900;
            margin-bottom: 5px;
        }
        
        .message-box.win .message-title {
            color: #00ff9d;
        }
        
        .message-box.lose .message-title {
            color: #ff0055;
        }
        
        .message-subtitle {
            font-size: 1rem;
            color: #888;
            margin-bottom: 20px;
        }
        

        
        .size-selector-panel {
            position: absolute;
            bottom: 150px;
            right: 130px;
            background: rgba(10, 10, 20, 0.85);
            border: 1px solid rgba(0, 245, 255, 0.3);
            border-radius: 12px;
            padding: 12px;
            backdrop-filter: blur(10px);
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .size-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7rem;
            color: #00f5ff;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            text-align: center;
        }
        
        .size-buttons {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .size-btn {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.6rem;
            font-weight: 700;
            padding: 6px 10px;
            border: 2px solid rgba(0, 245, 255, 0.4);
            border-radius: 6px;
            background: transparent;
            color: #00f5ff;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            white-space: nowrap;
        }
        
        .size-btn:hover {
            background: rgba(0, 245, 255, 0.2);
            border-color: #00f5ff;
        }
        
        .size-btn.active {
            background: rgba(0, 245, 255, 0.3);
            border-color: #00f5ff;
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.5);
        }
        
        .mine-selector-panel {
            position: absolute;
            bottom: 150px;
            right: 20px;
            background: rgba(10, 10, 20, 0.85);
            border: 1px solid rgba(255, 0, 229, 0.3);
            border-radius: 12px;
            padding: 12px;
            backdrop-filter: blur(10px);
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .selector-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7rem;
            color: #ff00e5;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            text-align: center;
        }
        
        .mine-buttons {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .mine-btn {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.75rem;
            font-weight: 700;
            width: 40px;
            height: 28px;
            border: 2px solid rgba(255, 0, 229, 0.4);
            border-radius: 6px;
            background: transparent;
            color: #ff00e5;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .mine-btn:hover {
            background: rgba(255, 0, 229, 0.2);
            border-color: #ff00e5;
        }
        
        .mine-btn.active {
            background: rgba(255, 0, 229, 0.3);
            border-color: #ff00e5;
            box-shadow: 0 0 10px rgba(255, 0, 229, 0.5);
        }
        

        .theme-toggle {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: auto;
            display: flex;
            gap: 10px;
        }
        
        .theme-btn, .rotate-btn {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.75rem;
            font-weight: 700;
            padding: 8px 20px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            background: rgba(10, 10, 20, 0.7);
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        
        .theme-btn:hover, .rotate-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: #fff;
        }
        
        .rotate-btn.stopped {
            border-color: #ff6600;
            color: #ff6600;
        }
        
        .ai-panel {
            position: absolute;
            top: 145px;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: auto;
            display: flex;
            gap: 10px;
        }
        
        .ai-btn {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.75rem;
            font-weight: 700;
            padding: 8px 20px;
            border: 1px solid rgba(0, 255, 157, 0.5);
            border-radius: 20px;
            background: rgba(0, 255, 157, 0.1);
            color: #00ff9d;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        
        .ai-btn:hover {
            background: rgba(0, 255, 157, 0.2);
            border-color: #00ff9d;
            box-shadow: 0 0 15px rgba(0, 255, 157, 0.3);
        }
        
        .ai-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .ai-btn.running {
            border-color: #ffcc00;
            color: #ffcc00;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Orbitron', sans-serif;
            color: #00f5ff;
            font-size: 1.2rem;
            letter-spacing: 0.3em;
        }
        
        .grid-glow {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(ellipse at 20% 80%, rgba(0, 245, 255, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 20%, rgba(255, 0, 229, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 50%, rgba(100, 100, 180, 0.1) 0%, transparent 70%);
            pointer-events: none;
            z-index: -1;
        }
    </style>
</head>
<body>
    <div class="grid-glow"></div>
    <div id="container">
        <div class="loading" id="loading">INITIALIZING...</div>
        
        <div class="ui-overlay" id="ui">
            <div class="header">
                <div class="title">MINESWEEPER</div>
                <div class="subtitle">3D Edition</div>
            </div>
            
            <div class="theme-toggle">
                <button class="theme-btn" id="langToggle">üåê JP</button>
                <button class="theme-btn" id="themeToggle">üåô Dark</button>
                <button class="rotate-btn stopped" id="rotateToggle">‚èπÔ∏è ÂõûËª¢ OFF</button>
                <button class="rotate-btn stopped" id="emptyToggle">‚¨ú Á©∫„Çª„É´ OFF</button>
                <button class="rotate-btn stopped" id="highlightToggle">üí° „Éè„Ç§„É©„Ç§„Éà OFF</button>
            </div>
            
            <div class="ai-panel">
                <button class="ai-btn" id="autoPlayBtn">ü§ñ Ëá™Âãï„Éó„É¨„Ç§</button>
            </div>
            
            <div class="stats-panel">
                <div class="stat-item">
                    <div class="stat-label">Time</div>
                    <div class="stat-value" id="timer">0:00</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Mines</div>
                    <div class="stat-value mines" id="mines">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Flags</div>
                    <div class="stat-value flags" id="flags">0</div>
                </div>
            </div>
            
            <div class="help-panel">
                <div class="help-title">Controls</div>
                <div class="help-item"><span>Â∑¶„ÇØ„É™„ÉÉ„ÇØ</span> - „Çª„É´„ÇíÈñã„Åè</div>
                <div class="help-item"><span>Âè≥„ÇØ„É™„ÉÉ„ÇØ</span> - „Éï„É©„Ç∞„ÇíÁ´ã„Å¶„Çã</div>
                <div class="help-item"><span>„Éâ„É©„ÉÉ„Ç∞</span> - ÂõûËª¢</div>
                <div class="help-item"><span>„Çπ„ÇØ„É≠„Éº„É´</span> - „Ç∫„Éº„É†</div>
                <div class="help-item"><span>Ctrl+„Çπ„ÇØ„É≠„Éº„É´</span> - ÈöôÈñìË™øÊï¥</div>
            </div>
            
            <div class="size-selector-panel">
                <span class="size-label">Size</span>
                <div class="size-buttons">
                    <button class="size-btn" data-size="3">ÂàùÁ¥ö<br>3√ó3√ó3</button>
                    <button class="size-btn active" data-size="5">‰∏≠Á¥ö<br>5√ó5√ó5</button>
                    <button class="size-btn" data-size="7">‰∏äÁ¥ö<br>7√ó7√ó7</button>
                </div>
            </div>
            
            <div class="mine-selector-panel">
                <span class="selector-label">Mines</span>
                <div class="mine-buttons">
                    <button class="mine-btn" data-mines="3">3</button>
                    <button class="mine-btn active" data-mines="5">5</button>
                    <button class="mine-btn" data-mines="10">10</button>
                    <button class="mine-btn" data-mines="15">15</button>
                    <button class="mine-btn" data-mines="20">20</button>
                    <button class="mine-btn" data-mines="25">25</button>
                </div>
            </div>
            
            <div class="controls-panel">
                <button class="btn btn-primary" id="newGame">New Game</button>
                <button class="btn btn-secondary" id="resetView">Reset View</button>
            </div>
            
            <div class="game-message" id="gameMessage">
                <div class="message-box" id="messageBox">
                    <div class="message-title" id="messageTitle">VICTORY</div>
                    <div class="message-subtitle" id="messageSubtitle">You cleared all mines!</div>
                    <button class="btn btn-primary" id="playAgain">Play Again</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game Configuration
        let GRID_SIZE = 5;
        let MINE_COUNT = 5;
        const CELL_SIZE = 1;
        let cellGap = 0.15;
        
        // Game State
        let cells = [];
        let gameOver = false;
        let gameWon = false;
        let gameStarted = false;
        let flagCount = 0;
        let revealedCount = 0;
        let timerInterval = null;
        let seconds = 0;
        
        // Three.js Variables
        let scene, camera, renderer, raycaster, mouse;
        let cubeGroup;
        let hoveredCell = null;
        
        // Number colors for dark theme
        const numberColorsDark = [
            null,
            '#00f5ff', // 1 - cyan
            '#00ff9d', // 2 - green
            '#ff00e5', // 3 - pink
            '#ffaa00', // 4 - orange
            '#ff0055', // 5 - red
            '#00ffff', // 6 - bright cyan
            '#ff77ff', // 7 - light pink
            '#ffffff'  // 8 - white
        ];
        
        // Number colors for light theme (darker, more visible)
        const numberColorsLight = [
            null,
            '#0066aa', // 1 - dark blue
            '#008844', // 2 - dark green
            '#aa0088', // 3 - dark magenta
            '#cc6600', // 4 - dark orange
            '#cc0033', // 5 - dark red
            '#007799', // 6 - teal
            '#880088', // 7 - purple
            '#333333'  // 8 - dark gray
        ];
        
        function getNumberColors() {
            return isDarkTheme ? numberColorsDark : numberColorsLight;
        }
        
        // Theme
        let isDarkTheme = true;
        let autoRotate = false;
        let showEmptyCells = false;
        let showHighlight = false;
        let currentLang = 'jp'; // 'jp', 'en', 'cn'
        
        // ÁøªË®≥„Éá„Éº„Çø
        const translations = {
            jp: {
                title: 'MINESWEEPER',
                subtitle: '3D Edition',
                time: 'Time',
                mines: 'Mines',
                flags: 'Flags',
                controls: 'Controls',
                leftClick: 'Â∑¶„ÇØ„É™„ÉÉ„ÇØ',
                openCell: '„Çª„É´„ÇíÈñã„Åè',
                rightClick: 'Âè≥„ÇØ„É™„ÉÉ„ÇØ',
                placeFlag: '„Éï„É©„Ç∞„ÇíÁ´ã„Å¶„Çã',
                drag: '„Éâ„É©„ÉÉ„Ç∞',
                rotate: 'ÂõûËª¢',
                scroll: '„Çπ„ÇØ„É≠„Éº„É´',
                zoom: '„Ç∫„Éº„É†',
                ctrlScroll: 'Ctrl+„Çπ„ÇØ„É≠„Éº„É´',
                adjustGap: 'ÈöôÈñìË™øÊï¥',
                size: 'Size',
                beginner: 'ÂàùÁ¥ö',
                intermediate: '‰∏≠Á¥ö',
                expert: '‰∏äÁ¥ö',
                newGame: 'New Game',
                resetView: 'Reset View',
                autoPlay: 'ü§ñ Ëá™Âãï„Éó„É¨„Ç§',
                victory: 'VICTORY',
                gameOver: 'GAME OVER',
                hitMine: 'You hit a mine!',
                playAgain: 'Play Again',
                rotateOn: 'üîÑ ÂõûËª¢ ON',
                rotateOff: '‚èπÔ∏è ÂõûËª¢ OFF',
                emptyOn: '‚¨õ Á©∫„Çª„É´ ON',
                emptyOff: '‚¨ú Á©∫„Çª„É´ OFF',
                highlightOn: 'üí° „Éè„Ç§„É©„Ç§„Éà ON',
                highlightOff: 'üí° „Éè„Ç§„É©„Ç§„Éà OFF'
            },
            en: {
                title: 'MINESWEEPER',
                subtitle: '3D Edition',
                time: 'Time',
                mines: 'Mines',
                flags: 'Flags',
                controls: 'Controls',
                leftClick: 'Left Click',
                openCell: 'Open cell',
                rightClick: 'Right Click',
                placeFlag: 'Place flag',
                drag: 'Drag',
                rotate: 'Rotate',
                scroll: 'Scroll',
                zoom: 'Zoom',
                ctrlScroll: 'Ctrl+Scroll',
                adjustGap: 'Adjust gap',
                size: 'Size',
                beginner: 'Easy',
                intermediate: 'Medium',
                expert: 'Hard',
                newGame: 'New Game',
                resetView: 'Reset View',
                autoPlay: 'ü§ñ Auto Play',
                victory: 'VICTORY',
                gameOver: 'GAME OVER',
                hitMine: 'You hit a mine!',
                playAgain: 'Play Again',
                rotateOn: 'üîÑ Rotate ON',
                rotateOff: '‚èπÔ∏è Rotate OFF',
                emptyOn: '‚¨õ Empty ON',
                emptyOff: '‚¨ú Empty OFF',
                highlightOn: 'üí° Highlight ON',
                highlightOff: 'üí° Highlight OFF'
            },
            cn: {
                title: 'MINESWEEPER',
                subtitle: '3D Áâà',
                time: 'Êó∂Èó¥',
                mines: 'Âú∞Èõ∑',
                flags: 'ÊóóÂ∏ú',
                controls: 'Êìç‰Ωú',
                leftClick: 'Â∑¶ÈîÆÁÇπÂáª',
                openCell: 'ÊâìÂºÄÊ†ºÂ≠ê',
                rightClick: 'Âè≥ÈîÆÁÇπÂáª',
                placeFlag: 'ÊîæÁΩÆÊóóÂ∏ú',
                drag: 'ÊãñÂä®',
                rotate: 'ÊóãËΩ¨',
                scroll: 'ÊªöËΩÆ',
                zoom: 'Áº©Êîæ',
                ctrlScroll: 'Ctrl+ÊªöËΩÆ',
                adjustGap: 'Ë∞ÉÊï¥Èó¥Èöô',
                size: 'Â§ßÂ∞è',
                beginner: 'ÂàùÁ∫ß',
                intermediate: '‰∏≠Á∫ß',
                expert: 'È´òÁ∫ß',
                newGame: 'Êñ∞Ê∏∏Êàè',
                resetView: 'ÈáçÁΩÆËßÜËßí',
                autoPlay: 'ü§ñ Ëá™Âä®Ê∏∏Êàè',
                victory: 'ËÉúÂà©',
                gameOver: 'Ê∏∏ÊàèÁªìÊùü',
                hitMine: 'Ë∏©Âà∞Âú∞Èõ∑‰∫ÜÔºÅ',
                playAgain: 'ÂÜçÁé©‰∏ÄÊ¨°',
                rotateOn: 'üîÑ ÊóãËΩ¨ ÂºÄ',
                rotateOff: '‚èπÔ∏è ÊóãËΩ¨ ÂÖ≥',
                emptyOn: '‚¨õ Á©∫Ê†º ÂºÄ',
                emptyOff: '‚¨ú Á©∫Ê†º ÂÖ≥',
                highlightOn: 'üí° È´ò‰∫Æ ÂºÄ',
                highlightOff: 'üí° È´ò‰∫Æ ÂÖ≥'
            }
        };
        
        const themes = {
            dark: {
                background: 0x1a1a2e,
                fog: 0x1a1a2e,
                ambient: 0x6060a0,
                hiddenBg1: '#3a3a5e',
                hiddenBg2: '#2a2a4e',
                hiddenBorder: '#5a5a8e',
                hiddenInner: '#6a6a9e',
                emptyBg: '#0a0a10',
                emptyBorder: '#222233',
                mineBg: '#1a0010',
                flagBg: '#1a1400',
                numberBg: '#0d0d15'
            },
            light: {
                background: 0xe8f4fc,
                fog: 0xe8f4fc,
                ambient: 0xffffff,
                hiddenBg1: '#7eb8e2',
                hiddenBg2: '#5a9fd4',
                hiddenBorder: '#3080c0',
                hiddenInner: '#4090d0',
                emptyBg: '#f0f8ff',
                emptyBorder: '#a0c8e8',
                mineBg: '#ffcccc',
                flagBg: '#fff0cc',
                numberBg: '#f5faff'
            }
        };
        
        function getCurrentTheme() {
            return isDarkTheme ? themes.dark : themes.light;
        }
        
        // Create number textures
        function createNumberTexture(number) {
            const theme = getCurrentTheme();
            const colors = getNumberColors();
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Background
            ctx.fillStyle = theme.numberBg;
            ctx.fillRect(0, 0, 128, 128);
            
            // Border glow
            const color = colors[number] || (isDarkTheme ? '#ffffff' : '#333333');
            ctx.strokeStyle = color;
            ctx.lineWidth = 4;
            ctx.strokeRect(4, 4, 120, 120);
            
            // Number with glow
            ctx.fillStyle = color;
            ctx.shadowColor = color;
            ctx.shadowBlur = isDarkTheme ? 15 : 5;
            ctx.font = 'bold 80px Arial, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(number.toString(), 64, 68);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        
        // Create empty revealed texture
        function createEmptyTexture() {
            const theme = getCurrentTheme();
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = theme.emptyBg;
            ctx.fillRect(0, 0, 128, 128);
            
            ctx.strokeStyle = theme.emptyBorder;
            ctx.lineWidth = 2;
            ctx.strokeRect(4, 4, 120, 120);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        
        // Create mine texture
        function createMineTexture() {
            const theme = getCurrentTheme();
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Background
            ctx.fillStyle = theme.mineBg;
            ctx.fillRect(0, 0, 128, 128);
            
            // Mine circle
            const mineColor = isDarkTheme ? '#ff0055' : '#cc0000';
            ctx.fillStyle = mineColor;
            ctx.shadowColor = mineColor;
            ctx.shadowBlur = isDarkTheme ? 20 : 10;
            ctx.beginPath();
            ctx.arc(64, 64, 35, 0, Math.PI * 2);
            ctx.fill();
            
            // Spikes
            ctx.strokeStyle = mineColor;
            ctx.lineWidth = 6;
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                ctx.beginPath();
                ctx.moveTo(64 + Math.cos(angle) * 30, 64 + Math.sin(angle) * 30);
                ctx.lineTo(64 + Math.cos(angle) * 50, 64 + Math.sin(angle) * 50);
                ctx.stroke();
            }
            
            // Center highlight
            ctx.fillStyle = isDarkTheme ? '#ff5588' : '#ff6666';
            ctx.shadowBlur = 0;
            ctx.beginPath();
            ctx.arc(54, 54, 12, 0, Math.PI * 2);
            ctx.fill();
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        
        // Create flag texture
        function createFlagTexture() {
            const theme = getCurrentTheme();
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Background
            ctx.fillStyle = theme.flagBg;
            ctx.fillRect(0, 0, 128, 128);
            
            const flagColor = isDarkTheme ? '#ffcc00' : '#cc8800';
            ctx.shadowColor = flagColor;
            ctx.shadowBlur = isDarkTheme ? 15 : 8;
            
            // Pole
            ctx.fillStyle = isDarkTheme ? '#aa8800' : '#885500';
            ctx.fillRect(58, 25, 6, 80);
            
            // Flag
            ctx.fillStyle = flagColor;
            ctx.beginPath();
            ctx.moveTo(64, 25);
            ctx.lineTo(100, 45);
            ctx.lineTo(64, 65);
            ctx.closePath();
            ctx.fill();
            
            // Base
            ctx.fillStyle = isDarkTheme ? '#aa8800' : '#885500';
            ctx.fillRect(45, 100, 38, 8);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        
        // Create wrong flag texture (flag with red X)
        function createWrongFlagTexture() {
            const theme = getCurrentTheme();
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Background - reddish
            ctx.fillStyle = isDarkTheme ? '#2a0a0a' : '#ffdddd';
            ctx.fillRect(0, 0, 128, 128);
            
            const flagColor = isDarkTheme ? '#ffcc00' : '#cc8800';
            ctx.shadowColor = flagColor;
            ctx.shadowBlur = isDarkTheme ? 10 : 5;
            
            // Pole
            ctx.fillStyle = isDarkTheme ? '#aa8800' : '#885500';
            ctx.fillRect(58, 25, 6, 80);
            
            // Flag
            ctx.fillStyle = flagColor;
            ctx.beginPath();
            ctx.moveTo(64, 25);
            ctx.lineTo(100, 45);
            ctx.lineTo(64, 65);
            ctx.closePath();
            ctx.fill();
            
            // Base
            ctx.fillStyle = isDarkTheme ? '#aa8800' : '#885500';
            ctx.fillRect(45, 100, 38, 8);
            
            // Red X overlay
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 10;
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 8;
            ctx.lineCap = 'round';
            
            // Draw X
            ctx.beginPath();
            ctx.moveTo(20, 20);
            ctx.lineTo(108, 108);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(108, 20);
            ctx.lineTo(20, 108);
            ctx.stroke();
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        
        // Create hidden cell texture
        function createHiddenTexture() {
            const theme = getCurrentTheme();
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Gradient background - brighter
            const gradient = ctx.createLinearGradient(0, 0, 128, 128);
            gradient.addColorStop(0, theme.hiddenBg1);
            gradient.addColorStop(1, theme.hiddenBg2);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 128, 128);
            
            // Border - brighter
            ctx.strokeStyle = theme.hiddenBorder;
            ctx.lineWidth = 3;
            ctx.strokeRect(4, 4, 120, 120);
            
            // Inner highlight
            ctx.strokeStyle = theme.hiddenInner;
            ctx.lineWidth = 1;
            ctx.strokeRect(8, 8, 112, 112);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        
        // Regenerate all textures
        function regenerateTextures() {
            textures.hidden = createHiddenTexture();
            textures.empty = createEmptyTexture();
            textures.mine = createMineTexture();
            textures.flag = createFlagTexture();
            textures.wrongFlag = createWrongFlagTexture();
            textures.highlight = createHighlightTexture();
            for (let i = 1; i <= 26; i++) {
                textures.numbers[i] = createNumberTexture(i);
            }
        }
        
        // Pre-generate textures
        const textures = {
            hidden: createHiddenTexture(),
            empty: createEmptyTexture(),
            mine: createMineTexture(),
            flag: createFlagTexture(),
            wrongFlag: createWrongFlagTexture(),
            highlight: createHighlightTexture(),
            numbers: [null]
        };
        
        // Generate number textures
        for (let i = 1; i <= 26; i++) {
            textures.numbers[i] = createNumberTexture(i);
        }
        
        // Size configurations
        const sizeConfigs = {
            3: { mines: [3, 5, 7, 10, 12], defaultMine: 5 },      // 27 cells
            5: { mines: [3, 5, 10, 15, 20, 25], defaultMine: 5 }, // 125 cells
            7: { mines: [5, 10, 20, 30, 40, 50], defaultMine: 10 } // 343 cells
        };
        
        function updateMineButtons() {
            const config = sizeConfigs[GRID_SIZE];
            const container = document.querySelector('.mine-buttons');
            container.innerHTML = '';
            
            config.mines.forEach(mineCount => {
                const btn = document.createElement('button');
                btn.className = 'mine-btn' + (mineCount === MINE_COUNT ? ' active' : '');
                btn.dataset.mines = mineCount;
                btn.textContent = mineCount;
                container.appendChild(btn);
            });
            
            // Re-add event listeners
            container.querySelectorAll('.mine-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    container.querySelectorAll('.mine-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    MINE_COUNT = parseInt(e.target.dataset.mines);
                    newGame();
                });
            });
        }
        
        function updateCellPositions() {
            const offset = (GRID_SIZE - 1) * (CELL_SIZE + cellGap) / 2;
            cells.forEach(cell => {
                cell.mesh.position.set(
                    cell.x * (CELL_SIZE + cellGap) - offset,
                    cell.y * (CELL_SIZE + cellGap) - offset,
                    cell.z * (CELL_SIZE + cellGap) - offset
                );
            });
        }
        
        function toggleTheme() {
            isDarkTheme = !isDarkTheme;
            const theme = getCurrentTheme();
            
            // Update button text
            document.getElementById('themeToggle').textContent = isDarkTheme ? 'üåô Dark' : '‚òÄÔ∏è Light';
            
            // Update scene background
            scene.background = new THREE.Color(theme.background);
            scene.fog = new THREE.Fog(theme.fog, 20, 40);
            
            // Update body background
            if (isDarkTheme) {
                document.body.style.background = 'linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%)';
            } else {
                document.body.style.background = 'linear-gradient(135deg, #87ceeb 0%, #b0d4f1 50%, #c0e0ff 100%)';
            }
            
            // Regenerate textures
            regenerateTextures();
            
            // Update all cells with new textures
            cells.forEach(cell => {
                if (cell.isRevealed) {
                    if (cell.isMine) {
                        updateCellTexture(cell, textures.mine, true);
                    } else if (cell.adjacentMines > 0) {
                        updateCellTexture(cell, textures.numbers[cell.adjacentMines], true);
                    } else {
                        updateCellTexture(cell, textures.empty, true);
                    }
                } else if (cell.isFlagged) {
                    updateCellTexture(cell, textures.flag, true);
                } else {
                    updateCellTexture(cell, textures.hidden, false);
                }
            });
        }
        
        function toggleRotation() {
            autoRotate = !autoRotate;
            const btn = document.getElementById('rotateToggle');
            const t = getTranslation();
            if (autoRotate) {
                btn.textContent = t.rotateOn;
                btn.classList.remove('stopped');
            } else {
                btn.textContent = t.rotateOff;
                btn.classList.add('stopped');
            }
        }
        
        function toggleEmptyCells() {
            showEmptyCells = !showEmptyCells;
            const btn = document.getElementById('emptyToggle');
            const t = getTranslation();
            if (showEmptyCells) {
                btn.textContent = t.emptyOn;
                btn.classList.remove('stopped');
            } else {
                btn.textContent = t.emptyOff;
                btn.classList.add('stopped');
            }
            
            // Êó¢„Å´Èñã„ÅÑ„ÅüÁ©∫„Çª„É´„ÅÆË°®Á§∫„ÇíÊõ¥Êñ∞
            cells.forEach(cell => {
                if (cell.isRevealed && cell.adjacentMines === 0 && !cell.isMine) {
                    cell.mesh.visible = showEmptyCells;
                }
            });
        }
        
        function toggleHighlight() {
            showHighlight = !showHighlight;
            const btn = document.getElementById('highlightToggle');
            const t = getTranslation();
            if (showHighlight) {
                btn.textContent = t.highlightOn;
                btn.classList.remove('stopped');
            } else {
                btn.textContent = t.highlightOff;
                btn.classList.add('stopped');
                // „Éè„Ç§„É©„Ç§„Éà„Çí„ÇØ„É™„Ç¢
                clearHighlightedNeighbors();
            }
        }
        
        function toggleLanguage() {
            // JP -> EN -> CN -> JP
            if (currentLang === 'jp') {
                currentLang = 'en';
            } else if (currentLang === 'en') {
                currentLang = 'cn';
            } else {
                currentLang = 'jp';
            }
            const langLabels = { jp: 'üåê JP', en: 'üåê EN', cn: 'üåê CN' };
            document.getElementById('langToggle').textContent = langLabels[currentLang];
            updateLanguageUI();
        }
        
        function getTranslation() {
            return translations[currentLang];
        }
        
        function updateLanguageUI() {
            const t = getTranslation();
            
            // „Çø„Ç§„Éà„É´
            document.querySelector('.title').textContent = t.title;
            document.querySelector('.subtitle').textContent = t.subtitle;
            
            // Stats
            document.querySelectorAll('.stat-label')[0].textContent = t.time;
            document.querySelectorAll('.stat-label')[1].textContent = t.mines;
            document.querySelectorAll('.stat-label')[2].textContent = t.flags;
            
            // Controls
            document.querySelector('.help-title').textContent = t.controls;
            const helpItems = document.querySelectorAll('.help-item');
            helpItems[0].innerHTML = `<span>${t.leftClick}</span> - ${t.openCell}`;
            helpItems[1].innerHTML = `<span>${t.rightClick}</span> - ${t.placeFlag}`;
            helpItems[2].innerHTML = `<span>${t.drag}</span> - ${t.rotate}`;
            helpItems[3].innerHTML = `<span>${t.scroll}</span> - ${t.zoom}`;
            helpItems[4].innerHTML = `<span>${t.ctrlScroll}</span> - ${t.adjustGap}`;
            
            // Size buttons
            document.querySelector('.size-label').textContent = t.size;
            const sizeBtns = document.querySelectorAll('.size-btn');
            sizeBtns[0].innerHTML = `${t.beginner}<br>3√ó3√ó3`;
            sizeBtns[1].innerHTML = `${t.intermediate}<br>5√ó5√ó5`;
            sizeBtns[2].innerHTML = `${t.expert}<br>7√ó7√ó7`;
            
            // Buttons
            document.getElementById('newGame').textContent = t.newGame;
            document.getElementById('resetView').textContent = t.resetView;
            document.getElementById('autoPlayBtn').textContent = t.autoPlay;
            document.getElementById('playAgain').textContent = t.playAgain;
            
            // Toggle buttons
            const rotateBtn = document.getElementById('rotateToggle');
            rotateBtn.textContent = autoRotate ? t.rotateOn : t.rotateOff;
            
            const emptyBtn = document.getElementById('emptyToggle');
            emptyBtn.textContent = showEmptyCells ? t.emptyOn : t.emptyOff;
            
            const highlightBtn = document.getElementById('highlightToggle');
            highlightBtn.textContent = showHighlight ? t.highlightOn : t.highlightOff;
        }
        
        // AI Solver
        let aiRunning = false;
        let aiInterval = null;
        
        // AI„ÅåÊ¨°„ÅÆ‰∏ÄÊâã„ÇíË®àÁÆó
        function getAIMove() {
            // Êú™ÈñãÂ∞Å„ÅÆ„Çª„É´„ÇíÂèñÂæó
            const hiddenCells = cells.filter(c => !c.isRevealed && !c.isFlagged);
            const revealedCells = cells.filter(c => c.isRevealed && c.adjacentMines > 0);
            
            // „Ç≤„Éº„É†ÈñãÂßãÂâç„Å™„Çâ‰∏≠Â§Æ‰ªòËøë„Çí„ÇØ„É™„ÉÉ„ÇØ
            if (revealedCells.length === 0 && hiddenCells.length > 0) {
                const center = Math.floor(GRID_SIZE / 2);
                const centerCell = getCell(center, center, center);
                if (centerCell && !centerCell.isRevealed) {
                    return { action: 'reveal', cell: centerCell, confidence: 'random' };
                }
                return { action: 'reveal', cell: hiddenCells[0], confidence: 'random' };
            }
            
            // 1. Á¢∫ÂÆöÁöÑ„Å™ÂÆâÂÖ®„Çª„É´„ÇíÊé¢„Åô
            for (const cell of revealedCells) {
                const neighbors = getNeighbors(cell);
                const hiddenNeighbors = neighbors.filter(n => !n.isRevealed && !n.isFlagged);
                const flaggedNeighbors = neighbors.filter(n => n.isFlagged);
                
                // Âë®Âõ≤„ÅÆ„Éï„É©„Ç∞Êï∞ = Èö£Êé•Âú∞Èõ∑Êï∞ „Å™„Çâ„ÄÅÊÆã„Çä„ÅØÂÖ®„Å¶ÂÆâÂÖ®
                if (flaggedNeighbors.length === cell.adjacentMines && hiddenNeighbors.length > 0) {
                    return { action: 'reveal', cell: hiddenNeighbors[0], confidence: 'certain' };
                }
            }
            
            // 2. Á¢∫ÂÆöÁöÑ„Å™Âú∞Èõ∑„Çª„É´„ÇíÊé¢„ÅôÔºà„Éï„É©„Ç∞„ÇíÁ´ã„Å¶„ÇãÔºâ
            for (const cell of revealedCells) {
                const neighbors = getNeighbors(cell);
                const hiddenNeighbors = neighbors.filter(n => !n.isRevealed && !n.isFlagged);
                const flaggedNeighbors = neighbors.filter(n => n.isFlagged);
                
                // Èö†„Çå„Çª„É´Êï∞ + „Éï„É©„Ç∞Êï∞ = Èö£Êé•Âú∞Èõ∑Êï∞ „Å™„Çâ„ÄÅÂÖ®„Å¶Âú∞Èõ∑
                if (hiddenNeighbors.length + flaggedNeighbors.length === cell.adjacentMines && hiddenNeighbors.length > 0) {
                    return { action: 'flag', cell: hiddenNeighbors[0], confidence: 'certain' };
                }
            }
            
            // 3. Á¢∫ÁéáË®àÁÆó„ÅßÊúÄ„ÇÇÂÆâÂÖ®„Å™„Çª„É´„ÇíÊé¢„Åô
            const probabilities = calculateMineProbabilities();
            
            if (probabilities.length > 0) {
                // ÊúÄ„ÇÇÂú∞Èõ∑Á¢∫Áéá„Åå‰Ωé„ÅÑ„Çª„É´„ÇíÈÅ∏Êäû
                probabilities.sort((a, b) => a.probability - b.probability);
                const safest = probabilities[0];
                
                if (safest.probability < 0.5) {
                    return { action: 'reveal', cell: safest.cell, confidence: 'probable', probability: safest.probability };
                } else if (safest.probability > 0.7) {
                    // È´òÁ¢∫Áéá„ÅßÂú∞Èõ∑„Å™„Çâ„Éï„É©„Ç∞
                    const mostDangerous = probabilities[probabilities.length - 1];
                    if (mostDangerous.probability > 0.7) {
                        return { action: 'flag', cell: mostDangerous.cell, confidence: 'probable', probability: mostDangerous.probability };
                    }
                }
                
                return { action: 'reveal', cell: safest.cell, confidence: 'guess', probability: safest.probability };
            }
            
            // 4. „É©„É≥„ÉÄ„É†„Å´ÈÅ∏ÊäûÔºàÊúÄÂæå„ÅÆÊâãÊÆµÔºâ
            if (hiddenCells.length > 0) {
                const randomCell = hiddenCells[Math.floor(Math.random() * hiddenCells.length)];
                return { action: 'reveal', cell: randomCell, confidence: 'random' };
            }
            
            return null;
        }
        
        // Âú∞Èõ∑Á¢∫Áéá„ÇíË®àÁÆó
        function calculateMineProbabilities() {
            const hiddenCells = cells.filter(c => !c.isRevealed && !c.isFlagged);
            const revealedCells = cells.filter(c => c.isRevealed && c.adjacentMines > 0);
            
            const probMap = new Map();
            
            // ÂêÑÈö†„Çå„Çª„É´„ÅÆÂú∞Èõ∑Á¢∫Áéá„ÇíË®àÁÆó
            for (const hidden of hiddenCells) {
                let totalWeight = 0;
                let mineWeight = 0;
                
                // Èö£Êé•„Åô„ÇãÈñã„ÅÑ„Åü„Çª„É´„Åã„ÇâÊÉÖÂ†±„ÇíÂèéÈõÜ
                const revealedNeighbors = getNeighbors(hidden).filter(n => n.isRevealed && n.adjacentMines > 0);
                
                if (revealedNeighbors.length === 0) {
                    // ÊÉÖÂ†±„Åå„Å™„ÅÑÂ†¥Âêà„ÅØ„Éá„Éï„Ç©„É´„ÉàÁ¢∫Áéá
                    const remainingMines = MINE_COUNT - cells.filter(c => c.isFlagged).length;
                    const remainingHidden = hiddenCells.length;
                    probMap.set(hidden, remainingMines / remainingHidden);
                } else {
                    for (const revealed of revealedNeighbors) {
                        const neighbors = getNeighbors(revealed);
                        const hiddenNeighbors = neighbors.filter(n => !n.isRevealed && !n.isFlagged);
                        const flaggedNeighbors = neighbors.filter(n => n.isFlagged);
                        
                        const remainingMines = revealed.adjacentMines - flaggedNeighbors.length;
                        const probability = remainingMines / hiddenNeighbors.length;
                        
                        totalWeight += 1;
                        mineWeight += probability;
                    }
                    
                    probMap.set(hidden, mineWeight / totalWeight);
                }
            }
            
            return Array.from(probMap.entries()).map(([cell, probability]) => ({ cell, probability }));
        }
        
        // Ëá™Âãï„Éó„É¨„Ç§
        function toggleAutoPlay() {
            startAutoPlay();
        }
        
        function startAutoPlay() {
            if (gameOver) return;
            
            aiRunning = true;
            document.getElementById('autoPlayBtn').style.display = 'none';
            
            aiInterval = setInterval(() => {
                if (gameOver || !aiRunning) {
                    stopAutoPlay();
                    return;
                }
                
                const move = getAIMove();
                if (!move) {
                    stopAutoPlay();
                    return;
                }
                
                if (move.action === 'flag') {
                    toggleFlag(move.cell);
                } else {
                    revealCell(move.cell);
                }
            }, 200);
        }
        
        function stopAutoPlay() {
            aiRunning = false;
            if (aiInterval) {
                clearInterval(aiInterval);
                aiInterval = null;
            }
        }

        // Popup drag functionality
        let popupDragging = false;
        let popupOffset = { x: 0, y: 0 };
        
        function setupPopupDrag() {
            const popup = document.getElementById('gameMessage');
            
            popup.addEventListener('mousedown', (e) => {
                if (e.target.tagName === 'BUTTON') return; // Don't drag when clicking button
                
                popupDragging = true;
                popup.classList.add('dragging');
                
                const rect = popup.getBoundingClientRect();
                popupOffset.x = e.clientX - rect.left;
                popupOffset.y = e.clientY - rect.top;
                
                // Remove transform so positioning works correctly
                popup.style.transform = 'none';
                popup.style.left = rect.left + 'px';
                popup.style.top = rect.top + 'px';
                popup.style.bottom = 'auto';
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!popupDragging) return;
                
                const popup = document.getElementById('gameMessage');
                popup.style.left = (e.clientX - popupOffset.x) + 'px';
                popup.style.top = (e.clientY - popupOffset.y) + 'px';
            });
            
            document.addEventListener('mouseup', () => {
                if (popupDragging) {
                    popupDragging = false;
                    document.getElementById('gameMessage').classList.remove('dragging');
                }
            });
        }
        
        // Initialize
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.Fog(0x1a1a2e, 20, 40);
            
            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(8, 8, 8);
            camera.lookAt(0, 0, 0);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Raycaster
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Lights
            const ambientLight = new THREE.AmbientLight(0x6060a0, 0.8);
            scene.add(ambientLight);
            
            const mainLight = new THREE.DirectionalLight(0xffffff, 1.0);
            mainLight.position.set(10, 20, 10);
            mainLight.castShadow = true;
            scene.add(mainLight);
            
            const fillLight = new THREE.PointLight(0x00f5ff, 0.6, 30);
            fillLight.position.set(-8, 8, -8);
            scene.add(fillLight);
            
            const backLight = new THREE.PointLight(0xff00e5, 0.5, 30);
            backLight.position.set(8, -8, 8);
            scene.add(backLight);
            
            const bottomLight = new THREE.PointLight(0x4444ff, 0.4, 25);
            bottomLight.position.set(0, -10, 0);
            scene.add(bottomLight);
            
            // Create game
            createGame();
            
            // Controls
            setupControls();
            
            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('click', onClick);
            document.addEventListener('contextmenu', onRightClick);
            
            document.getElementById('newGame').addEventListener('click', newGame);
            document.getElementById('playAgain').addEventListener('click', newGame);
            document.getElementById('resetView').addEventListener('click', resetView);
            document.getElementById('langToggle').addEventListener('click', toggleLanguage);
            document.getElementById('themeToggle').addEventListener('click', toggleTheme);
            document.getElementById('rotateToggle').addEventListener('click', toggleRotation);
            document.getElementById('emptyToggle').addEventListener('click', toggleEmptyCells);
            document.getElementById('highlightToggle').addEventListener('click', toggleHighlight);
            document.getElementById('autoPlayBtn').addEventListener('click', toggleAutoPlay);
            
            // Mine buttons
            document.querySelectorAll('.mine-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.mine-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    MINE_COUNT = parseInt(e.target.dataset.mines);
                    newGame();
                });
            });
            
            // Size buttons
            document.querySelectorAll('.size-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.size-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    GRID_SIZE = parseInt(e.target.dataset.size);
                    const config = sizeConfigs[GRID_SIZE];
                    MINE_COUNT = config.defaultMine;
                    updateMineButtons();
                    newGame();
                });
            });
            

            
            // Hide loading
            document.getElementById('loading').style.display = 'none';
            
            // Setup popup drag
            setupPopupDrag();
            
            // Start animation
            animate();
        }
        
        function createGame() {
            // Clear previous game
            if (cubeGroup) {
                scene.remove(cubeGroup);
            }
            cells = [];
            
            cubeGroup = new THREE.Group();
            scene.add(cubeGroup);
            
            const offset = (GRID_SIZE - 1) * (CELL_SIZE + cellGap) / 2;
            
            // Create cells
            for (let x = 0; x < GRID_SIZE; x++) {
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let z = 0; z < GRID_SIZE; z++) {
                        const cell = createCell(x, y, z, offset);
                        cells.push(cell);
                        cubeGroup.add(cell.mesh);
                    }
                }
            }
            
            // Place mines
            placeMines();
            
            // Calculate adjacent mines
            calculateAdjacentMines();
            
            // Update UI
            updateUI();
        }
        
        function createCell(x, y, z, offset) {
            const geometry = new THREE.BoxGeometry(CELL_SIZE * 0.85, CELL_SIZE * 0.85, CELL_SIZE * 0.85);
            
            // Calculate distance from center for opacity
            const centerDist = Math.sqrt(
                Math.pow(x - (GRID_SIZE - 1) / 2, 2) +
                Math.pow(y - (GRID_SIZE - 1) / 2, 2) +
                Math.pow(z - (GRID_SIZE - 1) / 2, 2)
            );
            const maxDist = Math.sqrt(3 * Math.pow((GRID_SIZE - 1) / 2, 2));
            const isOuter = centerDist > maxDist * 0.5;
            
            // Create materials for all 6 faces with the hidden texture
            const materials = [];
            for (let i = 0; i < 6; i++) {
                materials.push(new THREE.MeshPhongMaterial({
                    map: textures.hidden,
                    transparent: true,
                    opacity: isOuter ? (isDarkTheme ? 0.35 : 0.5) : (isDarkTheme ? 0.6 : 0.7),
                    shininess: 100,
                    depthWrite: false
                }));
            }
            
            const mesh = new THREE.Mesh(geometry, materials);
            
            mesh.position.set(
                x * (CELL_SIZE + cellGap) - offset,
                y * (CELL_SIZE + cellGap) - offset,
                z * (CELL_SIZE + cellGap) - offset
            );
            
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            const cell = {
                mesh,
                x, y, z,
                isMine: false,
                isRevealed: false,
                isFlagged: false,
                adjacentMines: 0,
                isOuter: isOuter
            };
            
            mesh.userData.cell = cell;
            
            return cell;
        }
        
        function placeMines() {
            let placed = 0;
            while (placed < MINE_COUNT) {
                const index = Math.floor(Math.random() * cells.length);
                if (!cells[index].isMine) {
                    cells[index].isMine = true;
                    placed++;
                }
            }
        }
        
        function calculateAdjacentMines() {
            cells.forEach(cell => {
                if (cell.isMine) return;
                
                let count = 0;
                getNeighbors(cell).forEach(neighbor => {
                    if (neighbor.isMine) count++;
                });
                cell.adjacentMines = count;
            });
        }
        
        function getNeighbors(cell) {
            const neighbors = [];
            
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dz = -1; dz <= 1; dz++) {
                        if (dx === 0 && dy === 0 && dz === 0) continue;
                        
                        const nx = cell.x + dx;
                        const ny = cell.y + dy;
                        const nz = cell.z + dz;
                        
                        if (nx >= 0 && nx < GRID_SIZE &&
                            ny >= 0 && ny < GRID_SIZE &&
                            nz >= 0 && nz < GRID_SIZE) {
                            const neighbor = cells.find(c => 
                                c.x === nx && c.y === ny && c.z === nz
                            );
                            if (neighbor) neighbors.push(neighbor);
                        }
                    }
                }
            }
            
            return neighbors;
        }
        
        function revealCell(cell, delay = 0) {
            if (cell.isRevealed || cell.isFlagged || gameOver) return;
            
            if (!gameStarted) {
                gameStarted = true;
                startTimer();
            }
            
            cell.isRevealed = true;
            revealedCount++;
            
            if (cell.isMine) {
                // Game Over - show mine
                updateCellTexture(cell, textures.mine, true);
                gameOver = true;
                endGame(false);
                revealAllMines();
                return;
            }
            
            // Delayed reveal animation
            setTimeout(() => {
                // Update cell appearance with pop animation
                cell.mesh.scale.set(0.1, 0.1, 0.1);
                updateCellAppearance(cell);
                
                // Animate scale
                animateCellReveal(cell);
            }, delay);
            
            // Auto-reveal if no adjacent mines
            if (cell.adjacentMines === 0) {
                let neighborDelay = delay + 8;
                getNeighbors(cell).forEach(neighbor => {
                    if (!neighbor.isRevealed && !neighbor.isFlagged) {
                        revealCell(neighbor, neighborDelay);
                        neighborDelay += 5;
                    }
                });
            }
            
            // Check win condition after delay
            setTimeout(() => checkWin(), delay + 20);
        }
        
        function animateCellReveal(cell) {
            const targetScale = cell.adjacentMines === 0 ? 0.4 : 1.0;
            const duration = 50;
            const startTime = performance.now();
            const startScale = 0.1;
            
            function animate() {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Easing function (ease out back for bounce effect)
                const easeOutBack = 1 + 2.70158 * Math.pow(progress - 1, 3) + 1.70158 * Math.pow(progress - 1, 2);
                const scale = startScale + (targetScale - startScale) * easeOutBack;
                
                cell.mesh.scale.set(scale, scale, scale);
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else if (cell.adjacentMines === 0) {
                    // Á©∫„Çª„É´Ë°®Á§∫Ë®≠ÂÆö„Å´Âü∫„Å•„ÅÑ„Å¶Ë°®Á§∫/ÈùûË°®Á§∫
                    cell.mesh.visible = showEmptyCells;
                }
            }
            
            requestAnimationFrame(animate);
        }
        
        function updateCellTexture(cell, texture, isRevealed = false) {
            const materials = [];
            // Inner cells are more visible when revealed
            // Light mode needs higher opacity for visibility
            const baseOpacity = isRevealed ? 0.95 : (cell.isOuter ? (isDarkTheme ? 0.35 : 0.5) : (isDarkTheme ? 0.6 : 0.7));
            for (let i = 0; i < 6; i++) {
                materials.push(new THREE.MeshPhongMaterial({
                    map: texture,
                    transparent: true,
                    opacity: baseOpacity,
                    shininess: 80,
                    depthWrite: isRevealed
                }));
            }
            cell.mesh.material = materials;
        }
        
        function updateCellAppearance(cell) {
            if (cell.adjacentMines > 0) {
                updateCellTexture(cell, textures.numbers[cell.adjacentMines], true);
            } else {
                updateCellTexture(cell, textures.empty, true);
                // Scale will be set by animation
            }
        }
        
        function toggleFlag(cell) {
            if (cell.isRevealed || gameOver) return;
            
            cell.isFlagged = !cell.isFlagged;
            
            if (cell.isFlagged) {
                updateCellTexture(cell, textures.flag, true);
                flagCount++;
            } else {
                updateCellTexture(cell, textures.hidden, false);
                flagCount--;
            }
            
            updateUI();
        }
        
        function revealAllMines() {
            cells.forEach(cell => {
                if (cell.isMine && !cell.isFlagged) {
                    // Âú∞Èõ∑„Åß„Éï„É©„Ç∞„Åå„Å™„ÅÑ„ÇÇ„ÅÆ„ÅØÂú∞Èõ∑„ÇíË°®Á§∫
                    updateCellTexture(cell, textures.mine, true);
                } else if (!cell.isMine && cell.isFlagged) {
                    // Âú∞Èõ∑„Åò„ÇÉ„Å™„ÅÑ„ÅÆ„Å´„Éï„É©„Ç∞„ÇíÁ´ã„Å¶„Åü„ÇÇ„ÅÆ„ÅØ‚úï„ÇíË°®Á§∫
                    updateCellTexture(cell, textures.wrongFlag, true);
                }
            });
        }
        
        function checkWin() {
            const totalCells = GRID_SIZE * GRID_SIZE * GRID_SIZE;
            const nonMineCells = totalCells - MINE_COUNT;
            
            console.log('checkWin:', revealedCount, '/', nonMineCells);
            
            if (revealedCount >= nonMineCells && !gameOver) {
                gameOver = true;
                gameWon = true;
                
                // Auto-flag remaining mines
                flagAllMines();
                
                endGame(true);
            }
        }
        
        function flagAllMines() {
            cells.forEach(cell => {
                if (cell.isMine && !cell.isFlagged) {
                    cell.isFlagged = true;
                    updateCellTexture(cell, textures.flag, true);
                    flagCount++;
                }
            });
            updateUI();
        }
        
        function endGame(won) {
            stopTimer();
            
            const t = getTranslation();
            const messageEl = document.getElementById('gameMessage');
            const boxEl = document.getElementById('messageBox');
            const titleEl = document.getElementById('messageTitle');
            const subtitleEl = document.getElementById('messageSubtitle');
            
            if (won) {
                boxEl.className = 'message-box win';
                titleEl.textContent = t.victory;
                subtitleEl.textContent = `Time: ${formatTime(seconds)}`;
            } else {
                boxEl.className = 'message-box lose';
                titleEl.textContent = t.gameOver;
                subtitleEl.textContent = t.hitMine;
            }
            
            messageEl.classList.add('show');
        }
        
        function newGame() {
            // Stop AI if running
            stopAutoPlay();
            // Show auto play button again
            document.getElementById('autoPlayBtn').style.display = 'block';
            
            gameOver = false;
            gameWon = false;
            gameStarted = false;
            flagCount = 0;
            revealedCount = 0;
            seconds = 0;
            stopTimer();
            
            // Reset gap to initial value
            cellGap = 0.15;
            
            // Reset rotation to OFF
            autoRotate = false;
            const rotateBtn = document.getElementById('rotateToggle');
            const t = getTranslation();
            rotateBtn.textContent = t.rotateOff;
            rotateBtn.classList.add('stopped');
            
            // Reset empty cells to OFF
            showEmptyCells = false;
            const emptyBtn = document.getElementById('emptyToggle');
            emptyBtn.textContent = t.emptyOff;
            emptyBtn.classList.add('stopped');
            
            // Reset highlight to OFF
            showHighlight = false;
            const highlightBtn = document.getElementById('highlightToggle');
            highlightBtn.textContent = t.highlightOff;
            highlightBtn.classList.add('stopped');
            
            const popup = document.getElementById('gameMessage');
            popup.classList.remove('show');
            // Reset popup position
            popup.style.transform = 'none';
            popup.style.left = '20px';
            popup.style.bottom = '150px';
            popup.style.top = 'auto';
            
            document.getElementById('timer').textContent = '0:00';
            
            createGame();
            resetView();
        }
        
        function startTimer() {
            timerInterval = setInterval(() => {
                seconds++;
                document.getElementById('timer').textContent = formatTime(seconds);
            }, 1000);
        }
        
        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }
        
        function formatTime(s) {
            const mins = Math.floor(s / 60);
            const secs = s % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        function updateUI() {
            document.getElementById('mines').textContent = MINE_COUNT;
            document.getElementById('flags').textContent = flagCount;
        }
        
        // Controls
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let dragDistance = 0;
        
        function setupControls() {
            renderer.domElement.addEventListener('mousedown', (e) => {
                if (e.button === 0) {
                    isDragging = true;
                    dragDistance = 0;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            renderer.domElement.addEventListener('mouseleave', () => {
                isDragging = false;
            });
            
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging && cubeGroup) {
                    const deltaMove = {
                        x: e.clientX - previousMousePosition.x,
                        y: e.clientY - previousMousePosition.y
                    };
                    
                    dragDistance += Math.abs(deltaMove.x) + Math.abs(deltaMove.y);
                    
                    // „Ç´„É°„É©Ë¶ñÁÇπ„Å´Âü∫„Å•„ÅÑ„ÅüÂõûËª¢ÔºàÂ∏∏„Å´„Éû„Ç¶„ÇπÊñπÂêë„Å´ÂõûËª¢Ôºâ
                    const rotationSpeed = 0.005;
                    
                    // „Ç´„É°„É©„ÅÆÂè≥ÊñπÂêë„Å®‰∏äÊñπÂêë„ÇíÂèñÂæó
                    const cameraRight = new THREE.Vector3();
                    const cameraUp = new THREE.Vector3();
                    camera.getWorldDirection(new THREE.Vector3());
                    cameraRight.setFromMatrixColumn(camera.matrixWorld, 0);
                    cameraUp.setFromMatrixColumn(camera.matrixWorld, 1);
                    
                    // Ê∞¥Âπ≥ÊñπÂêë„ÅÆ„Éâ„É©„ÉÉ„Ç∞ ‚Üí „Ç´„É°„É©„ÅÆ‰∏äÊñπÂêë„ÇíËª∏„Å´ÂõûËª¢
                    const quaternionY = new THREE.Quaternion();
                    quaternionY.setFromAxisAngle(cameraUp, deltaMove.x * rotationSpeed);
                    
                    // ÂûÇÁõ¥ÊñπÂêë„ÅÆ„Éâ„É©„ÉÉ„Ç∞ ‚Üí „Ç´„É°„É©„ÅÆÂè≥ÊñπÂêë„ÇíËª∏„Å´ÂõûËª¢
                    const quaternionX = new THREE.Quaternion();
                    quaternionX.setFromAxisAngle(cameraRight, deltaMove.y * rotationSpeed);
                    
                    // ÂõûËª¢„ÇíÈÅ©Áî®
                    cubeGroup.quaternion.premultiply(quaternionY);
                    cubeGroup.quaternion.premultiply(quaternionX);
                    
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });
            
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                
                if (e.ctrlKey) {
                    // Ctrl + scroll: adjust gap
                    cellGap += e.deltaY * -0.002;
                    cellGap = Math.max(0.1, Math.min(1.5, cellGap)); // Clamp between 0.1 and 1.5
                    updateCellPositions();
                } else {
                    // Normal scroll: zoom
                    const zoomSpeed = 0.5;
                    camera.position.multiplyScalar(1 + e.deltaY * 0.001 * zoomSpeed);
                    
                    // Clamp zoom
                    const dist = camera.position.length();
                    if (dist < 5) camera.position.setLength(5);
                    if (dist > 30) camera.position.setLength(30);
                }
            }, { passive: false });
        }
        
        function resetView() {
            const duration = 500;
            const startTime = performance.now();
            
            // ÁèæÂú®„ÅÆÁä∂ÊÖã„Çí‰øùÂ≠ò
            const startQuaternion = cubeGroup.quaternion.clone();
            const targetQuaternion = new THREE.Quaternion(0, 0, 0, 1);
            
            const startCameraPos = camera.position.clone();
            const targetCameraPos = new THREE.Vector3(8, 8, 8);
            
            function animate() {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Ease out cubic
                const eased = 1 - Math.pow(1 - progress, 3);
                
                // „Ç≠„É•„Éº„Éñ„ÅÆÂõûËª¢„Çí„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
                if (cubeGroup) {
                    cubeGroup.quaternion.slerpQuaternions(startQuaternion, targetQuaternion, eased);
                }
                
                // „Ç´„É°„É©‰ΩçÁΩÆ„Çí„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
                camera.position.lerpVectors(startCameraPos, targetCameraPos, eased);
                camera.lookAt(0, 0, 0);
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }
            
            requestAnimationFrame(animate);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // ÁèæÂú®„Éè„Ç§„É©„Ç§„Éà‰∏≠„ÅÆÈö£Êé•„Çª„É´
        let highlightedNeighbors = [];
        
        // „Éè„Ç§„É©„Ç§„ÉàÁî®„ÉÜ„ÇØ„Çπ„ÉÅ„É£„Çí‰ΩúÊàê
        function createHighlightTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // ËñÑ„ÅÑÈªÑËâ≤„ÅÆ„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥ËÉåÊôØ
            const gradient = ctx.createLinearGradient(0, 0, 128, 128);
            gradient.addColorStop(0, '#b8a060');
            gradient.addColorStop(1, '#a08850');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 128, 128);
            
            // ËñÑ„ÇÅ„ÅÆÊû†Á∑ö
            ctx.strokeStyle = '#c8b070';
            ctx.lineWidth = 3;
            ctx.strokeRect(4, 4, 120, 120);
            
            // ÂÜÖÂÅ¥„ÅÆ„Éè„Ç§„É©„Ç§„Éà
            ctx.strokeStyle = '#b89860';
            ctx.lineWidth = 1;
            ctx.strokeRect(8, 8, 112, 112);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        
        // „Éè„Ç§„É©„Ç§„Éà„Çí„ÇØ„É™„Ç¢
        function clearHighlightedNeighbors() {
            highlightedNeighbors.forEach(cell => {
                if (!cell.isRevealed && !cell.isFlagged) {
                    updateCellTexture(cell, textures.hidden, false);
                }
            });
            highlightedNeighbors = [];
        }
        
        // Èö£Êé•„Çª„É´„Çí„Éè„Ç§„É©„Ç§„Éà
        function highlightNeighborCells(cell) {
            if (!showHighlight) return;
            if (!cell.isRevealed || cell.adjacentMines === 0) return;
            
            const neighbors = getNeighbors(cell);
            const hiddenNeighbors = neighbors.filter(n => !n.isRevealed && !n.isFlagged);
            
            hiddenNeighbors.forEach(neighbor => {
                // ËñÑ„ÅÑÈªÑËâ≤„ÅÆ„Éè„Ç§„É©„Ç§„Éà„ÉÜ„ÇØ„Çπ„ÉÅ„É£„ÇíÈÅ©Áî®
                const materials = [];
                for (let i = 0; i < 6; i++) {
                    materials.push(new THREE.MeshPhongMaterial({
                        map: textures.highlight,
                        transparent: true,
                        opacity: neighbor.isOuter ? (isDarkTheme ? 0.45 : 0.55) : (isDarkTheme ? 0.6 : 0.7),
                        shininess: 80,
                        depthWrite: false
                    }));
                }
                neighbor.mesh.material = materials;
                highlightedNeighbors.push(neighbor);
            });
        }
        
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Raycast for hover
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cubeGroup ? cubeGroup.children : []);
            
            // Reset previous hover
            if (hoveredCell && !hoveredCell.isRevealed && !hoveredCell.isFlagged) {
                // Reset scale
                hoveredCell.mesh.scale.set(1, 1, 1);
            }
            
            // Clear previous highlighted neighbors
            clearHighlightedNeighbors();
            
            if (intersects.length > 0 && !isDragging) {
                const cell = intersects[0].object.userData.cell;
                if (cell && !cell.isRevealed && !cell.isFlagged) {
                    cell.mesh.scale.set(1.1, 1.1, 1.1);
                    hoveredCell = cell;
                    document.body.style.cursor = 'pointer';
                } else if (cell && cell.isRevealed && cell.adjacentMines > 0) {
                    // Êï∞Â≠ó„Çª„É´„Å´„Éõ„Éê„Éº„Åó„Åü„ÇâÂë®Âõ≤„ÅÆÊú™ÈñãÂ∞Å„Çª„É´„Çí„Éè„Ç§„É©„Ç§„Éà
                    highlightNeighborCells(cell);
                    hoveredCell = null;
                    document.body.style.cursor = 'pointer';
                } else {
                    hoveredCell = null;
                    document.body.style.cursor = 'default';
                }
            } else {
                hoveredCell = null;
                document.body.style.cursor = isDragging ? 'grabbing' : 'default';
            }
        }
        
        function onClick(event) {
            if (!cubeGroup || dragDistance > 5) return;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cubeGroup.children);
            
            if (intersects.length > 0) {
                const cell = intersects[0].object.userData.cell;
                if (cell) {
                    revealCell(cell);
                }
            }
        }
        
        function onRightClick(event) {
            event.preventDefault();
            if (!cubeGroup) return;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cubeGroup.children);
            
            if (intersects.length > 0) {
                const cell = intersects[0].object.userData.cell;
                if (cell) {
                    toggleFlag(cell);
                }
            }
        }
        
        // Animation
        function animate() {
            requestAnimationFrame(animate);
            
            // Slow auto rotation when not interacting
            if (cubeGroup && !isDragging && !gameOver && autoRotate) {
                cubeGroup.rotation.y += 0.001;
            }
            
            renderer.render(scene, camera);
        }
        
        // Start
        init();
    </script>
</body>
</html>
